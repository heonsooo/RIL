# 알고리즘 복잡도

## 1. 알고리즘 복잡도 계산이 필요한 이유

**하나의 문제를 푸는 알고리즘은 다양할 수 있다.**

- 다양한 알고리즘 중 어느 알고리즘이 더 좋은지 분석하기 위해, 복잡도를 정의하고 계산한다.
- 어떤 문제를 푸는데 수 많은 방법이 존재하지만, 그 중 가장 좋은 해결 방법을 고르기 위해서 시간 복잡도가 가장 빠른( 실행이 빠른 ) 알고리즘을 사용하기 위해 시간복잡도를 계산한다.

## 2. 알고리즘 복잡도 계산 항목
1. 시간복잡도 : 알고리즘 실행 속도
2. 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈

일반적으로 공간 복잡도를 계산하기 쉽지 않다. 

따라서 **가장 중요한 시간 복잡도를 꼭 이해하고 계산할 수 있어야 한다.**



어떤 문제를 해결하는데 많은 알고리즘이 있을 수 있다.
그 중 어떤 알고리즘이 가장 좋은 알고리즘인지 판단하기 위한 기준이 있어야 한다.
그러한 기준이 알고리즘 복잡도 표현 방법을 고안하기 시작했다.
그 중 알고리즘 복잡도 표현 방법 중 가장 중요한 것이 시간복잡도와 공간 복잡도이다.
시간 복잡도는 성능(실행속도)이 빠른 것, 공간 복잡도는 메모리를 얼마나 사용하는가에 대한 기준이 있다.
그 중 시간복잡도가 더 중요하다. 

> **[요약]**
> 다양한 알고리즘(풀이법) 중에 어느 것이 더 효율적인지 판별하기 위해 시간복잡도를 사용한다.

## 3. 알고리즘 시간 복잡도의 주요 요소

**시간복잡도는 반복문이 지배한다.**
> 반복문이 가장 큰 요소이다.

- 알고리즘과 마찬가지로, **프로그래밍**에서 **시간 복잡도**에 가장 영향을 많이 미치는 요소는 **반복문**이다.
- 입력의 크기가 커지면 커질수록 반복문이 알고리즘 수행 시간을 지배한다.


## 4. 알고리즘 성능 표기법
- **Big O(빅-오) 표기법 : O(N)**
  - 알고리즘 **최악의 실행 시간**을 표기한다.
  - 가장 많이 사용하며 가장 일반적으로 사용한다.
  - 최악의 실행 시간이 의미하는 것은, 아무리 최악의 상황이라도, 이 정도의 성능은 보장한다는 의미이다. 다시 말해서, **최대 시간**을 의미한다.
- Ω(오메가) 표기법 : Ω(N)
  - 오메가 표기법은 알고리즘 **최상의 실행 시간**을 표기한다.
- Θ(세타) 표기법 : Θ(N)
  - 세타 표기법은 알고리즘 **평균 실행 시간**을 표기한다.

시간 복잡도 계산은 반복문이 핵심 요소임을 인지하고, 계산 표기는 최상, 평균, 최악 중 최악의 시간인 Big-O 표기법을 중심으로 익히자.

### Big-O표기법 
 - O(입력 N )
   - 입력 N에 따라 결정되는 시간 복잡도 함수이다.
   -  O(1), O($log n$), O(n), O(n$log n$), O($n^2$), O($2^n$), O(n!)등으로 표기함
  - 입력 n 의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있다.
    - 입력 **n**에 따라, 몇 번 실행이 되는지 계산한다.
    - n이 1, 100, 1000이든 상수 번 만큼 실행 된다면, O(1)이다.
    - n이 n번, n+10번, 3n + 10 번 실행 된다면, O(n)이다.
    - n이 $n^2$번, $3n^2$번, 100$n^2$ - 100 번 실행 된다면, O($n^2$)이다.  
    - 가장 큰 차수를 빅오 안에 넣고, 이때 n은 **반복문**을 의미한다. 
    - **가장 높은 차수가 빅오 표기법의 입력 값이 된다.**
    >  [**빠름**]   O(1) < O($log n$) < O(n) < O(n$log n$) < O($n^2$) < O($2^n$) < O(n!) [**느림**]
    - 위 순서처럼 왼쪽으로 갈 수록 빠르기 때문에 더 좋은 알고리즘이다.


> **[정리]**
> 알고리즘을 구현하는 방법이 여러가지이다.
> 정량적으로 평가하기 위해 평가방법이 나왔다.
> 그 중에서도 시간복잡도가 가장 중요하다.
> 시간복잡도 측정 방법 중에서 빅오표기법을 가장 많이 사용한다.
> 따라서 빅오표기법을 이해해야한다.
> 시간복잡도는 입력 계수인 n에 따라 좌우된다. 
> 이때 중점적으로 n에 연결되는 것이 반복문이다.
> 따라서 반복문이 많아지면, 빅오가 커지고 시간복잡도가 커지기 때문에 알고리즘 성능이 좋지 않다고 판단된다.
> 따라서 알고리즘 성능이 좋다 => 시간 복잡도가 낮다 => 빅오 표기법 입력 값이 작다 => 반복문이 적다. 